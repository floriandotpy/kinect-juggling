\documentclass[dvipsnames]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
    %backgroundcolor=\color[rgb]{0.95,0.95,0.95},
    columns=flexible, 
    numbers=left, 
    numbersep=8pt, 
    xleftmargin=5pt,
    numberstyle=\scriptsize\color[rgb]{0.700,0.700,0.700}, 
    basicstyle=\ttfamily\scriptsize,
    captionpos=b,
    %keywordstyle=\color{Mahogany},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color{MidnightBlue},
    breaklines=true,
    frame=shadowbox,
    rulesepcolor=\color[rgb]{0.7,0.7,0.7} % color of box-shadow
}
\usepackage{verbatim} % mainly for multi-line comments


\title{Speeding up Python using Cython}
\author[Rolf $\cdot$ Thiemo $\cdot$ Flo]{Rolf Boomgaarden $\cdot$ Thiemo Gries $\cdot$ Florian Letsch}
\institute{UniversitÃ¤t Hamburg}
\date{November 28th, 2013}

\begin{document}

\frame
{
\titlepage
}

%\frame
%{
%\tableofcontents
%}

\section{Introducing Cython}
\begin{frame}{What is Cython?}
FIXME bullet points
\end{frame}

\begin{frame}[fragile]{Hello World}
\begin{lstlisting}[language=Python]
print "Hello World"
\end{lstlisting}

\begin{lstlisting}[language=Python]
from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize("helloworld.pyx")
)
\end{lstlisting}

\begin{lstlisting}[language=Python]
$ python setup.py build_ext --inplace
\end{lstlisting}

\begin{lstlisting}[language=Python]
>>> import helloworld
Hello World
\end{lstlisting}

\end{frame}

\begin{frame}{Cython workflow}
FIXME
\end{frame}


\section{Image processing}

\begin{frame}{A real world example}
EXAMPLE
\end{frame}

\begin{frame}[fragile]{Pure Python}
\begin{lstlisting}[language=Python,caption={add1.py}]
import numpy as np

def my_add(a, b):
    (...)
	
    dtype = a.dtype
    height = a.shape[0]
    width = a.shape[1]

    result = np.zeros((height, width), dtype=dtype)

    for y in range(height):
        for x in range(width):
            result[y,x] = a[y,x] + b[y,x]

    return result
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Python run through Cython}
\begin{lstlisting}[language=Python,caption={add2.pyx}]
import numpy as np

def my_add(a, b):
    (...)
	
    dtype = a.dtype
    height = a.shape[0]
    width = a.shape[1]

    result = np.zeros((height, width), dtype=dtype)

    for y in range(height):
        for x in range(width):
            result[y,x] = a[y,x] + b[y,x]

    return result
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Cython: Adding types}

\begin{lstlisting}[language=Python,caption={add3.pyx}]
import numpy as np
cimport numpy as np

DTYPE = np.uint8
ctypedef np.uint8_t DTYPE_t

def my_add(np.ndarray a, np.ndarray b):
    (...)
    cdef int height = a.shape[0]
    cdef int width = a.shape[1]
    cdef np.ndarray result = np.zeros((height, width), dtype=DTYPE)

    cdef int x, y
    for y in range(height):
        for x in range(width):
            result[y,x] = a[y,x] + b[y,x]

    return result
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Cython: Efficient indexing}
\begin{lstlisting}[language=Python,caption={add4.pyx}]
import numpy as np
cimport numpy as np

DTYPE = np.uint8
ctypedef np.uint8_t DTYPE_t

def my_add(np.ndarray[DTYPE_t, ndim=2] a, np.ndarray[DTYPE_t, ndim=2] b):
    (...)
    cdef int height = a.shape[0]
    cdef int width = a.shape[1]
    cdef np.ndarray[DTYPE_t, ndim=2] result = np.zeros((height, width), dtype=DTYPE)

    cdef int x, y
    for y in range(height):
        for x in range(width):
            result[y,x] = a[y,x] + b[y,x]

    return result
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Cython: Don't check boundaries}
\begin{lstlisting}[language=Python,caption={add5.pyx}]
import numpy as np; cimport numpy as np; cimport cython

DTYPE = np.uint8
ctypedef np.uint8_t DTYPE_t

@cython.boundscheck(False)
def my_add(np.ndarray[DTYPE_t, ndim=2] a, np.ndarray[DTYPE_t, ndim=2] b):
    (...)
    cdef int height = a.shape[0]
    cdef int width = a.shape[1]
    cdef np.ndarray[DTYPE_t, ndim=2] result = np.zeros((height, width), dtype=DTYPE)

    cdef int x, y
    for y in range(height):
        for x in range(width):
            result[y,x] = a[y,x] + b[y,x]

    return result
\end{lstlisting}
\end{frame}

\section{Speedup}

\begin{frame}[fragile]{Cython vs numpy}

\begin{lstlisting}[language=Python,caption={add6.pyx}]
import numpy as np; cimport numpy as np

DTYPE = np.uint8
ctypedef np.uint8_t DTYPE_t

def my_add(np.ndarray[DTYPE_t, ndim=2] a, np.ndarray[DTYPE_t, ndim=2] b):
    if a.shape[0] != b.shape[0] or a.shape[1] != b.shape[1]:
        raise ValueError("Arrays must have identical dimensions")
    if a.dtype != DTYPE or b.dtype != DTYPE:
        raise ValueError("Arrays must have type %s" % DTYPE)

    return a + b
\end{lstlisting}
\end{frame}

\section{More features?}

\begin{frame}{Conclusion}
FIXME: speedup, how much fun to work with, easy use of features, documentation etc
\end{frame}

\begin{frame}{The end}
EOF

(FIXME: better joke)
\end{frame}

\end{document}






